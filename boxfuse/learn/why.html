---
layout: learn
menu: why
subtitle: 'Why Immutable Infrastructure?'
---
<div id="getstarted-why">
    <p class="doc-title">Why Immutable Infrastructure?</p>

    <p>Let's assume we have an application. To produce a deliverable, we need to build it from source. This involves
        compiling sources,
        processing and copying resources, and probably a few more steps.</p>

    <p>In its simplest form this process looks like this:</p>

    <p><img src="/assets/img/learn/build.png" alt="Build"/></p>

    <p>The resulting application deliverable (typically a .jar or .war file for JVM-based apps) is</p>

    <ul>
        <li>a single immutable unit</li>
        <li>built once and stored in an artifact repository</li>
        <li>regenerated by the continuous integration system after every change</li>
    </ul>

    <p class="doc-section">The Software Stack</p>

    <div class="row">
        <div class="col-md-8">
            <p>The application of course doesn't run directly on bare metal. Whether on your laptop or on a server, it
                requires a
                stack of software to execute.</p>

            <p>A typical server application requires an app server (embedded in the app or not) and a language runtime
                (like the JVM). The language runtime itself uses various libraries and runs on top of an OS kernel which
                drives the
                hardware.</p>
        </div>
        <div class="col-md-4"><img src="/assets/img/learn/stack.png" alt="Stack"/></div>
    </div>

    <p class="doc-section">Multiple Machines &amp; Environments</p>

    <p>In all but the simplest projects, there are several machines the application needs to run on, organized in
        multiple environments.
        <strong>The application is gradually promoted from environment to environment.</strong>
        This ensures that what is run in production, is what was tested in test. To achieve this, the same application
        is pulled from the artifact repository and deployed unchanged to the different machines:
    </p>

    <p><img src="/assets/img/learn/environments.png" alt="Environments"/></p>

    <p><strong>This avoids the classic mistake of building a separate artifact per environment</strong> and effectively
        taking the risk of running something potentially different on all machines.
    </p>

    <p>Yet when we look at the remaining layers of our stack, this is exactly what is happening!</p>

    <p>It is the job of the system administrator to ensure that these machines are as identical as possible, yet each is
        built individually. All changes, patches and upgrades need to be performed on all machines.
        The sheer complexity of this task and the numerous moving parts make this very difficult to achieve reliably.
        Even with automated configuration tools and recipes it's easy for some minor detail to slip through the cracks!</p>

    <p>So what could potentially go wrong?</p>

    <p>Here is just of short list of issues, most of which you will probably already have encountered:</p>

    <ul>
        <li>some additional software is missing</li>
        <li>a resource (directory, ...) has been created under the wrong name</li>
        <li>the wrong version of some software is installed (usually the old one with the bug)</li>
        <li>permissions have been set incorrectly</li>
        <li>a critical resource (port, ...) is occupied</li>
    </ul>

    <p>If these are the risks, then <strong>why aren't we holding our systems to the same standards as our applications</strong>
        by applying the same principles for building them?</p>

    <p>Why are we still building works of art and snowflake servers when what we need is an army of clones?</p>

    <p class="doc-section">Immutable Infrastructure</p>

    <p>This is where Immutable Infrastructure comes in.</p>

    <p>Instead of assembling just the application, the whole machine is now packaged as a single immutable unit. It contains the
        entire software stack and it is regenerated by the continuous integration server after every change:</p>

    <p><img src="/assets/img/learn/image.png" alt="Machine Image"/></p>

    <p>Instead of having to worry about updating many moving parts at all layers, <strong>the whole Machine Image is now
    promoted unchanged from Environment to Environment.</strong> Effectively finally making sure that what we run in production
    is what we tested in test.</p>

    <p><img src="/assets/img/learn/promote.png" alt="Promote"/></p>

    <p>Getting this right can be challenging. Boxfuse makes it a breeze.</p>

    <p class="next-steps">
        <a class="btn btn-primary" href="/learn/how">How Boxfuse works <i class="fa fa-arrow-right"></i></a>
    </p>
</div>